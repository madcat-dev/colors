#!/usr/bin/env bash

# is using as library
[[ "${0}" != "${BASH_SOURCE}" ]] && \
    RGB_UTIL_1EBE2_LIB=true || RGB_UTIL_1EBE2_LIB=""

LC_ALL=C

# Default colors (Tango theme)
declare -A COLOR=(
    [0]=#282a2e      [8]=#373b41
    [1]=#a54242      [9]=#cc6666
    [2]=#8c9440     [10]=#b5bd68
    [3]=#de935f     [11]=#f0c674
    [4]=#5f819d     [12]=#81a2be
    [5]=#85678f     [13]=#b294bb
    [6]=#5e8d87     [14]=#8abeb7
    [7]=#707880     [15]=#c5c8c6
)

# -----------------------------------------------------------------------------
# Notify functions
# -----------------------------------------------------------------------------

normal() {
    [[ $(tput colors) -eq 256 ]] && \
        echo -e "\033[38;2;208;208;208m${@}\033[0m" >&2 || \
        echo -e "\033[37m${@}\033[0m" >&2
}

success() {
    [[ $(tput colors) -eq 256 ]] && \
        echo -e "\033[38;2;144;165;126m${@}\033[0m" >&2 || \
        echo -e "\033[32m${@}\033[0m" >&2
}

warning() {
    [[ $(tput colors) -eq 256 ]] && \
        echo -e "\033[38;2;215;157;101m${@}\033[0m" >&2 || \
        echo -e "\033[33m${@}\033[0m" >&2
}

error() {
    [[ $(tput colors) -eq 256 ]] && \
        echo -e "\033[38;2;162;102;102m${@}\033[0m" >&2 || \
        echo -e "\033[31m${@}\033[0m" >&2

    if [[ ${ERROR_IS_FATAL} ]]; then
        kill -9 $$; sleep 3; return 1
    fi
}

fatal() {
    [[ $(tput colors) -eq 256 ]] && \
        echo -e "\033[38;2;207;0;0m${@}\033[0m" >&2 || \
        echo -e "\033[31;1m${@}\033[0m" >&2

    kill -9 $$; sleep 3; return 1
}


# -----------------------------------------------------------------------------
# Math and types utilites
# -----------------------------------------------------------------------------

isint() {
    local tmp
    printf -v tmp "%d" ${1/+/} 2>/dev/null
    [[ ${tmp} && ${tmp} == ${1/+/} ]] && \
        echo "$tmp" || return 1
}

int() {
    local val=$(isint ${1%.*})
    [[ ${val} ]] && \
        echo $val && return

    fatal "Not integer value: '${1}'"
}

byte() {
    local val=$(isint ${1%.*})
    [[ ${val} && $val -ge 0 && $val -le 255 ]] && \
        echo $val && return

    fatal "Not byte value: '${1}'"
}

int8() {
    local val=$(int ${1})

    [[ $val -lt -128 ]] && val=-128
    [[ $val -gt  127 ]] && val=127
    echo $val
}

uint8() {
    local val=$(int ${1})

    [[ $val -lt   0 ]] && val=0
    [[ $val -gt 255 ]] && val=255
    echo $val
}

grad() {
    echo $(( $(int ${1}) % 360 ))
}

ugrad() {
    local val=$(grad ${1})
    [[ $val -lt 0 ]] && \
        echo $(( 360 + $val )) || echo $val
}

min() {
    local MIN
    local next
    for next in ${@}; do
        [[ ! ${MIN} ]] && \
            MIN=$(int ${next}) && continue

        next=$(int ${next})
        [[ $next && "$next" -lt "$MIN" ]] && \
            MIN=${next}
    done
    echo "${MIN}"
}

max() {
    local MAX
    local next
    for next in ${@}; do
        [[ ! ${MAX} ]] && \
            MAX=$(int ${next}) && continue

        next=$(int ${next})
        [[ $next && "$next" -gt "$MAX" ]] && \
            MAX=${next}
    done
    echo "${MAX}"
}

isfloat() {
    local tmp
    printf -v tmp "%f" ${1/+/} 2>/dev/null
    [[ ${1/+/} && ${tmp} ]] && \
        echo "$tmp" || return 1
}

float() {
    local val=$(isfloat ${1})
    [[ ${val} ]] && \
        echo $val && return

    fatal "Not float value: '${1}'"
}

round() {
    local val=$(float ${1})
    printf -v val "%.${2:-0}f" "$val" 2>/dev/null || return 1
    echo ${val}
}

floor() {
    local val=$(float ${1})
    val=( ${val/./ } )
    [[ ${val} -lt 0 && ${val[1]} -gt 0 ]] && \
        echo $(( $val - 1 )) || echo $val
}

ceil() {
    local val=$(float ${1})
    val=( ${val/./ } )
    [[ ${val} -ge 0 && ${val[1]} -gt 0 ]] && \
        echo $(( $val + 1 )) || echo $val
}

at() {
    local value=${1:-undefined}; shift
    [[ " ${@} " == *" $value "* ]] && \
        echo true
}


# -----------------------------------------------------------------------------
# Colors functions
# -----------------------------------------------------------------------------

isrgb() {
    local RGB
    if [[ ${#1} == 7 && ${1:0:1} == "#" ]]; then
        printf -v RGB "%d %d %d" \
            0x${1:1:2} 0x${1:3:2} 0x${1:5:2} 2>/dev/null && \
            echo "$RGB"
    fi
}

rgb() {
    local val=$(isrgb ${1%.*})
    [[ ${val} ]] && \
        echo $val && return

    fatal "Invalid color '${1}'"
}

rgb_to_hex() {
    printf "#%02X%02X%02X" \
        $(uint8 ${1}) \
        $(uint8 ${2}) \
        $(uint8 ${3})
}

rgb_to_hsv() {
    local RGB=( $(rgb ${1}) )
    local r=${RGB[0]}  # integer 0..255
    local g=${RGB[1]}  # integer 0..255
    local b=${RGB[2]}  # integer 0..255

    local maxc=$(max $r $g $b)
    local minc=$(min $r $g $b)

    # Value: color brightness {0..100}
    local v=$(round $(echo "$maxc / 2.55" | bc -l))

    [[ "$minc" == "$maxc" ]] && \
        echo "0 0 $v" && return

    # Saturation: color saturation ("purity") {0..100}
    local s=$(round $(echo "($maxc - $minc) / $maxc * 100" | bc -l))

    # Hue: position in the spectrum {0..360}
    local h=0
    local rc=$(echo "($maxc - $r) / ($maxc - $minc)" | bc -l)
    local gc=$(echo "($maxc - $g) / ($maxc - $minc)" | bc -l)
    local bc=$(echo "($maxc - $b) / ($maxc - $minc)" | bc -l)

    if [[ $r == $maxc ]]; then
        h=$(echo "$bc - $gc" | bc -l)
    elif [[ $g == $maxc ]]; then
        h=$(echo "2.0 + $rc - $bc" | bc -l)
    else
        h=$(echo "4.0 + $gc - $rc" | bc -l)
    fi

    h=$(round $(echo "($h / 6.0) * 360" | bc -l))

    echo "$h $s $v"
}

hsv_to_rgb() {
    local h=$(ugrad ${1})
    local s=$(int ${2})
    local v=$(int ${3})

    if [[ $s -lt 0 || $s -gt 100 ]]; then
        fatal "Invalid saturation value"
    fi

    v=$(round $(echo "$v * 2.55" | bc -l))
    [[ $s -eq 0 ]] && \
        rgb_to_hex $v $v $v && return

    h=$(echo "$h / 360" | bc -l)
    s=$(echo "$s / 100" | bc -l)

    local i=$(floor $(echo "$h * 6.0" | bc -s)) # XXX assume int() truncates!
    local f=$(echo "$h * 6.0 - $i" | bc -l)
    local p=$(round $(echo "$v * (1.0 - $s)" | bc -l))
    local q=$(round $(echo "$v * (1.0 - $s * $f)" | bc -l))
    local t=$(round $(echo "$v * (1.0 - $s * (1.0 - $f))" | bc -l))

    i=$(( $i % 6 ))

    [[ $i -eq 0 ]] && \
        rgb_to_hex $v $t $p && return
    [[ $i -eq 1 ]] && \
        rgb_to_hex $q $v $p && return
    [[ $i -eq 2 ]] && \
        rgb_to_hex $p $v $t && return
    [[ $i -eq 3 ]] && \
        rgb_to_hex $p $q $v && return
    [[ $i -eq 4 ]] && \
        rgb_to_hex $t $p $v && return
    [[ $i -eq 5 ]] && \
        rgb_to_hex $v $p $q && return

    fatal "Error of hsv conversion"
}


rgb_hue() {
    local HSV=( $(rgb_to_hsv "${1}") )
    local h=${HSV[0]}
    local val=( $(parse_value ${2}) )
    local delta=${val[0]}

    # percent value
    [[ ${val[2]} ]] && \
        delta=$(round $(echo "$delta * 3.6" | bc -l))

    # absolute value
    [[ "${val[1]}" == "abs" ]] && \
        delta=$(( $delta - $h ))

    hsv_to_rgb \
        $(( $h + $delta )) \
        ${HSV[1]} \
        ${HSV[2]} 
}

rgb_saturation() {
    local HSV=( $(rgb_to_hsv "${1}") )
    local s=${HSV[1]}
    local val=( $(parse_value ${2}) )
    local delta=$(int ${val[0]})

    # absolute value
    [[ "${val[1]}" == "abs" ]] && \
        delta=$(( $delta - $s ))

    s=$(( $s + $delta ))
    [[ $s -lt   0 ]] && s=0
    [[ $s -gt 100 ]] && s=100

    hsv_to_rgb \
        ${HSV[0]} \
        $s \
        ${HSV[2]} 
}

rgb_value() {
    local HSV=( $(rgb_to_hsv "${1}") )
    local v=${HSV[2]}
    local val=( $(parse_value ${2}) )
    local delta=$(int ${val[0]})

    # percent value
    [[ ! ${val[2]} ]] && \
        delta=$(round $(echo "$delta / 2.55" | bc -l))

    # absolute value
    [[ "${val[1]}" == "abs" ]] && \
        delta=$(( $delta - $v ))

    v=$(( $v + $delta ))
    [[ $v -lt   0 ]] && s=0
    [[ $v -gt 100 ]] && s=100

    hsv_to_rgb \
        ${HSV[0]} \
        ${HSV[1]} \
        $v
}

rgb_inverse() {
    local RGB=( $(rgb ${1}) )
    rgb_to_hex \
        $((255 - ${RGB[0]})) \
        $((255 - ${RGB[1]})) \
        $((255 - ${RGB[2]}))
}


#
# args: <format str> <#color>
#
format() {
    local RGB=( $(rgb "${2}") )
    local HSV=( $(rgb_to_hsv "${2}") )

    local r=${RGB[0]}  # color 0..255
    local g=${RGB[1]}  # color 0..255
    local b=${RGB[2]}  # color 0..255

    local h=${HSV[0]}  # Hue: position in the spectrum 0..360
    local s=${HSV[1]}  # Luminance: color saturation ("purity") 0..100
    local v=${HSV[2]}  # Saturation: color brightness 0..100

    local R=$(printf "%02X" $r)  # hex color 00..FF
    local G=$(printf "%02X" $g)  # hex color 00..FF
    local B=$(printf "%02X" $b)  # hex color 00..FF

    eval "echo -e \"${1}\""
}


# -----------------------------------------------------------------------------
# Others utils
# -----------------------------------------------------------------------------

xrdbq() {
    xrdb -query | grep -w "${1}:" | cut -f 2
}

preview() {
    local name=${1:-xrdb}
    local len=$(echo "70 - ${#name} - 4" | bc -s)

    echo -en $(printf '─%.0s' $(seq $len)); echo -e "[ ${name} ]"
    echo -e  "  BLK      RED      GRN      YEL      BLU      MAG      CYN      WHT"
    echo -e  "$(printf '─%.0s' {1..70})"

    for i in {0..7}; do
        printf "\033[38;2;%03d;%03d;%03dm" $(rgb ${COLOR[$i]}) 
        echo -en "$([[ $i -gt 0 ]] && echo "  ")${COLOR[$i]}"
    done
    echo -e "\033[0m"

    for i in {8..15}; do
        printf "\033[38;2;%03d;%03d;%03dm" $(rgb ${COLOR[$i]}) 
        echo -en "$([[ $i -gt 8 ]] && echo "  ")${COLOR[$i]}"
    done
    echo -e "\033[0m"

    echo -e "$(printf '─%.0s' {1..70})"
}

function displaytime {
    local T=$1
    local W=$((T/60/60/24/7))
    local D=$((T/60/60/24%7))
    local H=$((T/60/60%24))
    local M=$((T/60%60))
    local S=$((T%60))

    if [[ $W > 0 ]]; then
        printf '%d weeks ' $W
        printf '%d days ' $D
    else
        if [[ $D > 0 ]]; then
            printf '%d days ' $D
            printf '%d hours ' $H
        else
            [[ $H > 0 ]] && printf '%d hours ' $H
            [[ $M > 0 ]] && printf '%d minutes ' $M
            [[ $H = 0 ]] && printf '%d seconds ' $S
        fi
    fi
    printf 'ago'
}


parse_value() {
    local val=${1}
    local md="abs"
    local pc

    [[ "+-" == *"${val:0:1}"* ]] && md="rel"

    if [[ ${val:$((${#val} - 1))} == "%" ]]; then
        val=$(float "${val:0:$((${#val} - 1))}")
        pc="%"
    else
        val=$(int "$val")
    fi

    echo "$val $md $pc"
}


# -----------------------------------------------------------------------------

# run in library mode?
[[ ${RGB_UTIL_1EBE2_LIB} ]] && return

# -----------------------------------------------------------------------------

restore_xrdb_colors() {
    for i in {0..15}; do
        local val=$(xrdbq "color$i")
        COLOR[$i]=$(rgb_to_hex $(rgb $val))
    done
}

verbose() {
    local _dl
    printf "\033[38;2;%03d;%03d;%03dm" $(rgb ${1})
    echo -en "${1}\033[0m("

    if [[ ${HUE} ]]; then
        [[ ${_dl} ]] && echo -en ", "
        echo -en "hue ${HUE}"
        _dl=true
    fi

    if [[ ${SAT} ]]; then
        [[ ${_dl} ]] && echo -en ", "
        echo -en "saturation ${SAT}"
        _dl=true
    fi

    if [[ ${VAL} ]]; then
        [[ ${_dl} ]] && echo -en ", "
        echo -en "value ${VAL}"
        _dl=true
    fi

    echo -en "): "
    printf "\033[38;2;%03d;%03d;%03dm" $(rgb ${2})
    echo -en "${2}\033[0m"
}


BASE="$(realpath "$(dirname "$0")")"
RESTORE=${RESTORE:-true}
VERBOSE=${VERBOSE:-true}

while [ -n "$1" ]; do
    case "${1}" in
    --default|-d)
        RESTORE=""
        ;;

    --hue|-H)
        parse_value "${2}" >/dev/null
        HUE="${2}"
        shift
        ;;

    --saturation|-S)
        parse_value "${2}" >/dev/null
        SAT="${2}"
        shift
        ;;

    --value|-V)
        parse_value "${2}" >/dev/null
        VAL="${2}"
        shift
        ;;

    --verbose)
        VERBOSE=true
        ;;

    --no-verbose|-n)
        VERBOSE=""
        ;;

    *)
        _source="${1}"
        ;;
    esac
    shift
done

if [[ ! ${_source} ]]; then
    [[ ${RESTORE} ]] && restore_xrdb_colors
    preview
    exit 0
fi

_out="$_source"

[[ ${HUE} ]] && _out=$(rgb_hue "$_out" "$HUE")
[[ ${SAT} ]] && _out=$(rgb_saturation "$_out" "$SAT")
[[ ${VAL} ]] && _out=$(rgb_value "$_out" "$VAL")

[[ ${VERBOSE} ]] && \
    echo -e "$(verbose $_source $_out)" >&2

echo "$_out"
